; Test set 0x0100
; 1. First, test imm -> reg, which has opcode 0xB0 - 0xBF.
mov_test_1:
mov al, 0xab
cmp al, 0xab
assert e, 0x0110
mov cl, 0xcd
cmp cl, 0xcd
assert e, 0x0111
mov dl, 0xbc 
cmp dl, 0xbc
assert e, 0x0112
mov bl, 0xda
cmp bl, 0xda
assert e, 0x0113
mov ah, 0xab
cmp ah, 0xab
assert e, 0x0114
mov ch, 0xcd
cmp ch, 0xcd
assert e, 0x0115
mov dh, 0xbc 
cmp dh, 0xbc
assert e, 0x0116
mov bh, 0xda
cmp bh, 0xda
assert e, 0x0117
mov ax, 0xabcd
cmp ax, 0xabcd
assert e, 0x0118
mov cx, 0xdabc
cmp cx, 0xdabc
assert e, 0x0119
mov dx, 0xcdab
cmp dx, 0xcdab
assert e, 0x011a
mov bx, 0xbcda
cmp bx, 0xbcda
assert e, 0x011b
mov sp, 0xdcba
cmp sp, 0xdcba
assert e, 0x011c
mov bp, 0xadcb
cmp bp, 0xadcb
assert e, 0x011d
mov si, 0xbadc
cmp si, 0xbadc
assert e, 0x011e
mov di, 0xcbad
cmp di, 0xcbad
assert e, 0x011f
; Then, test imm -> r/m.
mov_test_2:
; direct address / word
mov word [0xabcd], 0xbaba
cmp word [0xabcd], 0xbaba
assert e, 0x0120
; direct address / byte
mov byte [0xabcd], 0x0a
cmp byte [0xabcd], 0x0a
assert e, 0x0121
mov bx, 0xe000
mov_test_3:
; Test memory <-> ax
mov ax, 0x0000
mov word [0xabcd], 0xbaba
mov ax, [0xabcd]
cmp ax, 0xbaba
assert e, 0x0130
mov [0xfaff], ax
cmp word [0xfaff], 0xbaba
assert e, 0x0131
mov word [0xfafa], 0x0ff1
mov al, [0xfafa]
cmp al, 0xf1
assert e, 0x0132
mov [0xfaff], al
cmp byte [0xfaff], 0xf1
assert e, 0x0133
mov_test_4:
; Test r/m <-> reg
mov ax, 0xabcd
mov bx, ax
cmp bx, 0xabcd
assert e, 0x0140
mov [0xfaff], bx
mov cx, [0xfaff]
cmp cx, 0xabcd
assert e, 0x0141
; 8bit testing
mov al, 0xab
mov bl, al
cmp bl, 0xab
assert e, 0x0142
mov byte [0xfaff], al
mov byte cl, [0xfaff]
cmp cl, 0xab
assert e, 0x0143
mov_test_5:
; Test r/m <-> segreg
mov word [0xfaff], 0xaaaa
mov es, [0xfaff]
mov ax, es
cmp ax, 0xaaaa
assert e, 0x0150
mov_test_6:
; Shift the data segment...
mov ax, 0x1000
mov ds, ax
; Test every R/M combinations possible. Which isn't a lot actually.
; bx+si
; bx+di
; bp+si
; bp+di
; si
; di
; direct or bp
; bx
mov bx, 0x0001
mov bp, 0x0002
mov si, 0x0004
mov di, 0x0008
mov word [bx+si], 0x0001
cmp word [0x0005], 0x0001
assert e, 0x0160
mov word [bx+di], 0x0002
cmp word [0x0009], 0x0002
assert e, 0x0161
mov word [bp+si], 0x0003
cmp word [0x0006], 0x0003
assert e, 0x0162
mov word [bp+di], 0x0004
cmp word [0x000a], 0x0004
assert e, 0x0163
mov word [si], 0x0005
cmp word [0x0004], 0x0005
assert e, 0x0164
mov word [di], 0x0006
cmp word [0x0008], 0x0006
assert e, 0x0165
mov word [0x0002], 0x0007
cmp word [0x0002], 0x0007
assert e, 0x0166
mov word [bx], 0x0008
cmp word [0x0001], 0x0008
assert e, 0x0167
; Then with d8.
mov word [bx+si+0x50], 0x0001
cmp word [0x0055], 0x0001
assert e, 0x0168
mov word [bx+di+0x50], 0x0002
cmp word [0x0059], 0x0002
assert e, 0x0169
mov word [bp+0x50], 0x0007
cmp word [0x0052], 0x0007
assert e, 0x016a
mov word [bx+0x50], 0x0008
cmp word [0x0051], 0x0008
assert e, 0x016b
; ...d16
mov word [bx+0x5000], 0x0009
cmp word [0x5001], 0x0009
assert e, 0x016c
; Then with d8 with negative value.
mov word [bp+si-0x50], 0x0001
cmp word [0xffb6], 0x0001
assert e, 0x016d
; Then with d16 with negative value.
mov word [bp+di-0x5000], 0x0002
cmp word [0xb00a], 0x0002
assert e, 0x016e
